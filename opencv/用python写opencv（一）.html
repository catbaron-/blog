<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>用Python写OpenCV（一）</title>

</head>
<body>
<h1>用Python写OpenCV（一）</h1>

<p> <strong>前言</strong></p>

<p> <em>最近刚到岛国，研究室的方向是图像处理，虽然还没有固定的课题，但是openCV肯定是少不了的。但是C++实在是爱不起来，好在OpenCV支持python。于是决定参照《OpenCV Computer Vision With Python》来学习，顺道汉化一下。我也是边学边写，错误在所难免。观者勿怪。</em></p>

<p> <em>第一章是安装和配置，这里就不记了。需要的基本组件有</em></p>

<ul>
<li><em>python （2.7版本）</em></li>
<li><em>numpy 这是python的一个库，这里主要用来强化python的数组，把数组当做矩阵来计算</em></li>
<li><em>OpenCV 这个就不说了吧</em></li>
</ul>


<p> <em>看到这篇文章的这些环境应该都不是问题，不多说，下面从第二章开始</em></p>

<h2>第二章 处理文件、摄像头和GUI</h2>

<p>这一章会介绍OpenCV中I/O相关的功能，同时也会讨论项目的概念，并会开始一个面向对象设计的项目，在随后的章节中会逐渐完善这个项目。</p>

<p>通过开始学习I/O功能和设计模式，我们会像做三明治一样构建我们的项目：从外至内。先是外层，就像面包片，然后才是填充物，或者是算法之类的。我们之所以用这样的方式，是因为计算机视觉是要对外处理的——它要深入理解计算机外部的世界——而我们要做的是，在随后的章节中用一个统一的借口来把算法应用到所有的外部信息。</p>

<blockquote><p>所有本章的完整代码都可以在坐着的网站上下载到:<a href="http://nummist.com/opencv/3923_02.zip">http://nummist.com/opencv/3923_02.zip</a>.</p></blockquote>

<h3>2.1 基本的I/O脚本</h3>

<p>所有的CV应用都需要读入一张图片。其中大多数还会生成一张图片作为输出。一个交互式的CV应用可能还需要把摄像头作为输入源，并使用一个窗口作为输出端。然而，还有其他的输入源或者输出端，包括图片文件，视频文件和数位序列。比如数位序列可以通过网络连接来接受/发送，或者在通过算法来生成。我们来分别看一下这些方式。</p>

<h4>2.1.1 读/写图片文件</h4>

<p>OpenCV提供的imread()和imwrite()函数支持各种静态图片的文件格式。支持的文件格式随操作系统有所不同，但应该总是支持BMP格式。一般来说，也应该支持PNG，JPEG，和TIFF格式。图片可以从一种格式的文件中读取，然后存储为另一种格式。比如说，让我们来吧一张图片从PNG转化为JPEG：</p>

<pre><code>import cv2
image = cv2.imread('MyPic.png')
cv2.imwrite('MyPic.jpg', image)
</code></pre>

<blockquote><p>Tips：我们使用的大部分OpenCV功能都来自cv2模块。你可以浏览一下其他基于cv或者cv2.cv的OpenCV手册，但那是已经废弃的模块。当我们需要用到还没有包含到cv2中的内容时，我们会使用cv2.cv模块。</p></blockquote>

<p>imread()函数默认返回一个BGR图片，就算读入的时灰度图像也是一样。BGM(blue-green-red)与RGB(red-green-blue)图像一样，只是通道顺序互逆。</p>

<p>当然我们也可以指定imread()的读入模式为CV_LOAD_IMAGE_COLOR (BGR模式)，CV_LOAD_IMAGE_GRAYSCALE (灰度模式)，或者是CV_LOAD_IMAGE_UNCHANGED (根据读入文件的色彩空间决定是BGR模式还是灰度模式)。举个例子，我们来用灰镀膜是加在一张PNG图片（这样会失去图片信息），然后把它保存为一张只有灰度的PNG图片：</p>

<pre><code>import cv2
grayImage = cv2.imread('MyPic.png', cv2.CV_LOAD_IMAGE_GRAYSCALE)
cv2.imwrite('MyPicGray.png', grayImage)
</code></pre>

<p>不管是什么模式，imread()函数都会丢掉alpha通道（透明度）。imwrite()函数需要指定图片是BGR格式或者灰度格式，并且每个通道都需要有一定数位。举例来说，BMP格式每个通道需要8bit，PNG格式则允许每个通道有8bit或者16bit。</p>

<h4>2.1.2 图片和raw byte互相转换</h4>

<p>理论上来说，一个字节是一个0~255之间的整数。在实时图像普及的今天，一个像素通常会用每个通道上的一个字节表示，虽然其它表示方法也行的通。</p>

<p>一个OpenCV图像是一个二维或三维numpy.array数组。一个8bit的灰度图像是一个包含字节信息的二维数组，一个24bit的BGR图像是一个三维数组，同样也包含字节信息。我们可以通过类似于image[0, 0]或者image[0, 0, 0]的表达式来访问每个字节信息。其中第一个值是像素的y坐标，或者说“行”，0的意思是最上面。第二个值是像素的x坐标，或者说“列”，0的意思是在最左边。第三个值（如果有的话）表示的是色彩通道。</p>

<p>举个例子，在8bit的灰度图像中，如果在最左上的位置有一个白色的像素，那么image[0, 0]就是255。对一个24bit的BGR图像来说，如果在最左上的位置有一个蓝色的像素，那么image[0, 0]就是[255, 0, 0]。</p>

<blockquote><p>Tips：类似 image[0, 0] 或者 image[0, 0] = 128 的表达式只是一个选择，我们可以使用类似 image.item((0, 0)) 或者 image.setitem((0, 0), 128)的表达式。后者对于单个像素的操作更加高效。然而，我们在随后的章节中会看到，我们通常都需要在大规模的图层上操作，而不是对单个像素操作。</p></blockquote>

<p>既然图片在每个图层都有8bit数据，那么我们就可以把它转化为Python中标准的bytearray。这是一个一维数组：</p>

<pre><code>byteArray = bytearray(image)
</code></pre>

<p>同样的，既然bytearray是字节信息的有序排列，那么我们就可以把它们重组为一个numpy.array数组类型，也就是一张图片：</p>

<pre><code>grayImage = numpy.array(grayByteArray).reshape(height, width)
bgrImage = numpy.array(bgrByteArray).reshape(height, width, 3)
</code></pre>

<p>下面我们来看一个稍微复杂点的例子。我们来把一个随机的bytearray转换为一张灰度图像和BGR图像。</p>

<pre><code>   import cv2
   import numpy
   import os
   # Make an array of 120,000 random bytes.
   randomByteArray = bytearray(os.urandom(120000))
   flatNumpyArray = numpy.array(randomByteArray)
   # Convert the array to make a 400x300 grayscale image.
   grayImage = flatNumpyArray.reshape(300, 400)
   cv2.imwrite('RandomGray.png', grayImage)
   # Convert the array to make a 400x100 color image.
   bgrImage = flatNumpyArray.reshape(100, 400, 3)
   cv2.imwrite('RandomColor.png', bgrImage)
</code></pre>

<p>执行这个脚本之后，我们会在脚本的当前目录下得到一对随机生成的图片：RandomGray.png和RandomColor.png。</p>

<blockquote><p>在这里我们使用了Python标准的os.urandom()函数来得到随机数组，然后把它转换为numpy数组。需要注意的时，这里也可以直接生成一个随机的numpy数组（而且会更高效）。做法是numpy.random.randint(0, 256, 120000).reshape(300, 400)。我们这里使用os.urandom()的原因只是为了示范如何从raw bytes进行转换。</p></blockquote>
</body>
</html>