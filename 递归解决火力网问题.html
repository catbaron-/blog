<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>火力网问题在浙大OJ里面的的描述：</title>
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[['$$$','$$$']]}});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<p><link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css"></p>

<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>


<script>
hljs.tabReplace = ' ';
hljs.initHighlightingOnLoad();
</script>


<h4>火力网问题在浙大OJ里面的的描述：</h4>

<p>Suppose that we have a square city with straight streets. A map of a city is a square board with n rows and n columns, each representing a street or a piece of wall.</p>

<p>A blockhouse is a small castle that has four openings through which to shoot. The four openings are facing North, East, South, and West, respectively. There will be one machine gun shooting through each opening.</p>

<p>Here we assume that a bullet is so powerful that it can run across any distance and destroy a blockhouse on its way. On the other hand, a wall is so strongly built that can stop the bullets.</p>

<p>The goal is to place as many blockhouses in a city as possible so that no two can destroy each other. A configuration of blockhouses is legal provided that no two blockhouses are on the same horizontal row or vertical column in a map unless there is at least one wall separating them. In this problem we will consider small square cities (at most 4x4) that contain walls through which bullets cannot run through.</p>

<p>The following image shows five pictures of the same board. The first picture is the empty board, the second and third pictures show legal configurations, and the fourth and fifth pictures show illegal configurations. For this board, the maximum number of blockhouses in a legal configuration is 5; the second picture shows one way to do it, but there are several other ways.</p>

<p> Your task is to write a program that, given a description of a map, calculates the maximum number of blockhouses that can be placed in the city in a legal configuration.</p>

<p> The input file contains one or more map descriptions, followed by a line containing the number 0 that signals the end of the file. Each map description begins with a line containing a positive integer n that is the size of the city; n will be at most 4. The next n lines each describe one row of the map, with a '.' indicating an open space and an uppercase 'X' indicating a wall. There are no spaces in the input file.</p>

<p> For each test case, output one line containing the maximum number of blockhouses that can be placed in the city in a legal configuration.</p>

<hr />

<h4>再贴中文的描述：</h4>

<p>在一个n*n的网格里，每个网格可能为“墙壁”（用‘X’表示）和“街道”（用‘.’表示）。现在在街道放置碉堡，每个碉堡可以向上下左右四个方向开火，子弹射程无限远。墙壁可以阻挡子弹。问最多能放置多少个碉堡，使它们彼此不会互相摧毁。</p>

<p>配图说明如下：
<img src="http://acm.zju.edu.cn/onlinejudge/showImage.do?name=0000%2F1002%2F1002.gif" alt="fire net" /></p>

<hr />

<h4>思路</h4>

<p>我没有想出来如何生成最多碉堡的摆放方法。看到网上有人说在墙壁的四面分别摆放就可以了。没有详细研究。这里用的方法是递归遍历。实现语言为python。</p>

<p>大概思路是：</p>

<ol>
<li>对于第k个位置，判断是否可以摆放碉堡。</li>
<li>如果可以摆放，则将碉堡摆放在此处，并对k之后的所有位置进行递归判断。</li>
<li>如果不能摆放，则继续对k后面的位置进行判断（同级非递归）</li>
<li>k是最后一个位置，则对当前摆放的碉堡数量进行计数，对best数据更新。</li>
</ol>


<p>感觉递归的回溯与深度优先的遍历算法有些相似。</p>

<h4>代码</h4>

<pre><code>WALL = "X"  #输入矩阵中“X”代表城墙
HOUSE = "O" #输入矩阵中“0”代表碉堡

#定义地图类
class Map():
    #地图的规模
    X = 0
    Y = 0

    def __init__(this):
        this.maparr = []    #地图矩阵
        this.best = 0       #最优碉堡数量

    #根据输入的字符串生成地图矩阵
    def draw(this,string):
        # 这个map-lambda的函数是为了把类似“abcd”的字符串转化成["a","b","c","d"]的矩阵
        this.maparr.append(map(lambda a:a,string))
        #更新地图规模
        this.X = len(this.maparr)
        this.Y = len(this.maparr[0])

    #判断某个位置是否可以摆放
    def putable(this,x,y):
        #判断三个条件
        #1. 该位置是否有城墙
        #2. 同一行是否有不被城墙相隔的碉堡
        #3. 同一列是否有不被城墙相隔的碉堡
        return False if ((WALL == this.maparr[x][y]) or (not this.testX(x)) or (not this.testY(y))) else True

    #具体判断的时候，把行/列转化为字符串输入
    def test(this,string):
        #正常情况下，把一行用碉堡分割，除了两端的两段，每一段都应该包含至少一个城墙
        streets = string.split(HOUSE)
        if len(streets) &lt; 3:
            return True

        #去除两端
        streets.pop(0)
        streets.pop()

        #在分割出来的每一段中找城墙“X”，如果没找到说明碉堡相邻了
        for street in streets:
            if not (WALL in street):
                return False
        return True

#testX和testY分别把行和列转化为字符串然后调用test函数
def testX(this, x):
    string = "".join(this.maparr[x])
    return this.test(string)
def testY(this, y):
    string = ""
    for s in this.maparr:
        string = string + s[y]
    return this.test(string)

#递归函数
def findNext(this,k,best):
    #先确定地图规模
    X = this.X
    Y = this.Y

    #如果k是最后一个位置，那么比较best和当前碉堡数量，取大值
    if k == X*Y:
        if best &gt; this.best:
            this.best = best
        return

    #k不是最后一个，把k转化为xy坐标
    x = k/X
    y = k%Y
    #如果k处不是城墙，摆一个碉堡上去
    if this.maparr[x][y] != WALL:
        this.maparr[x][y] = HOUSE

    #判断这个碉堡是否合理
    if this.putable(x,y):
        #摆放合理，所以以此处有碉堡为前提继续在后面的位置递归测试
        best = best + 1
        while k &lt; X*Y:
            this.findNext(k+1, best)
            k = k+1
    #子递归返回后，要继续同级的处理，所以把碉堡擦除，由上级递归来继续测试
    if this.maparr[x][y] != WALL:
        this.maparr[x][y] = "."
    return

#kickoff函数，在这里开始调用递归过程
#以每一个位置为起点进行递归测试
def findBest(this):
    k = 0
    while k &lt; this.X * this.Y:
        this.findNext(k,0)
        k = k +1

#主函数
def main():
    maps = []    #地图数组，根据地图矩阵生成地图对象
    maparr = []    #地图矩阵数组，存储输入的地图矩阵
    i = 0    #用来处理地图矩阵

    for line in sys.stdin:
        if line == "0\n":
            break;
        maparr.append(line.strip())
    while i &lt; len(maparr):
        c = int(maparr[i])+i
        newmap = Map()
        while i &lt; c:
            i = i+1
            newmap.draw(maparr[i])
        maps.append(newmap)
        i = i+1
    for m in maps:
        m.findBest()
        print m.best
if __name__ == '__main__':
    main()
</code></pre>
</body>
</html>